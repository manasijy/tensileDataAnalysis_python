# -*- coding: utf-8 -*-
"""Stress_strain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KGqtsZb_mA8a74SeSHnSNDBwJ-DtTM0B
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import scipy 
from scipy.optimize import curve_fit
# %matplotlib inline

dataset = pd.read_csv('421FSP.csv',skiprows = 1)
stress = dataset.iloc[:, 4].values
strain = dataset.iloc[:, 3].values


plt.plot(strain, stress)
plt.xlabel("Strain")
plt.ylabel("Stress")
plt.title("Stress vs Strain Curve")

plt.plot(strain, stress)
plt.xlabel("Strain")
plt.ylabel("Stress")
plt.title("Stress vs Strain Curve")
plt.xlim([0.00,0.05])

smooth_width = 500
x1 = np.linspace(-6,6,smooth_width)
norm = np.sum(np.exp(-x1**2)) * (x1[1]-x1[0]) # ad hoc normalization
y1 = (4*x1**2 - 2) * np.exp(-x1**2) / smooth_width *8#norm*(x1[1]-x1[0])
y_conv = np.convolve(stress, y1, mode="same")
plt.plot(strain,y_conv, label = "second deriv")
plt.xlim([0,0.05])
plt.ylim([-10,10])

max_variation = -5.0
min_variation = -1.0
count_of_variable = 0
zero_value = 0
n = len(strain)
for i in range (n):
  if(y_conv[i] >= min_variation):
    zero_value = i
  if(y_conv[i] <= max_variation):
    count_of_variable = i
    break

plt.plot(strain, stress)
plt.xlabel("Strain")
plt.ylabel("Stress")
plt.title("Stress vs Strain Curve")
plt.show()
plt.xlim([strain[zero_value],strain[count_of_variable]])

#finding the slope and the intercept of our line
array_length = count_of_variable - zero_value +1
better_strain = [None]*array_length
moved_strain = [None]*array_length
better_stress = [None]*array_length
for i in range(array_length):
  better_strain[i] = strain[zero_value + i]
  better_stress[i] = stress[zero_value + i]
  moved_strain[i] = better_strain[i] +0.002; 
coef = np.polyfit(better_strain,better_stress,1)
print(coef)

plt.plot(better_strain, better_stress)
plt.plot(moved_strain, better_stress)

err = stress - np.polyval([coef[0],(coef[1]-0.002*coef[0])], strain)
[index] = np.where(abs(err)== min(abs(err)))
yieldStress = stress[index]
yieldStress

TrueStrain = np.log(np.ones(len(strain))+strain)
TrueStress = stress*(np.ones(len(strain))+strain)
TruePlasticStrain = TrueStrain -stress*(1/coef[0])
maxStressIndex = np.where(stress == max(stress))
indx = index[0]
maxStressIndx = maxStressIndex[0]

TplStrain =TruePlasticStrain[indx:maxStressIndx[0]]-TruePlasticStrain[indx];
TplStress= TrueStress[indx:maxStressIndx[0]]
UTS = TrueStress[maxStressIndx[0]];
UTS_Engg = max(stress);
plt.plot((TplStrain),TplStress,'-r');
plt.ylim([0,1000]);
print(UTS, UTS_Engg)

plt.plot((TruePlasticStrain[indx:maxStressIndx[0]]-TruePlasticStrain[indx]),TrueStress[indx:maxStressIndx[0]],'-r');

def objective(x, a, b, c, d, e, f, g, h, i):
 return a * x + b * x**2 + c*x**3 + d*x**4 + e*x**5 + f*x**6 + g*x**7 + h*np.sqrt(0.001+x) + i

popt, _ = curve_fit(objective, TplStrain,TplStress)
a, b, c, d, e, f, g, h, i = popt
print('y = %.5f * x + %.5f * x^2 + %.5f*x^3 + %.5f *x^4 + %.5f *x^5 + %.5f*x^6 + %.5f *x^7 + %.5f * sqrt(0.001+x) + %.5f' % (a, b, c, d, e, f, g, h, i))

plt.figure(figsize=(15, 5))
plt.scatter(TplStrain, TplStress)
plt.xlim([0.0,0.052])
plt.ylim([190,350])
y_line = objective(TplStrain, a, b, c, d, e, f, g, h, i)
plt.plot(TplStrain, y_line, color='red', marker='o', linestyle='dashed',linewidth=1, markersize=1)
plt.xlabel('True Stress')
plt.ylabel('True Plastic Strain')

KMY = np.gradient(objective(TplStrain, a, b, c, d, e, f, g, h, i), TplStrain);
KMX = objective(TplStrain, a, b, c, d, e, f, g, h, i)
plt.plot(KMX,KMY)
plt.xlabel( 'True Stress - Yield Stress (MPa)' );
plt.ylabel( 'd(sigma)/d(epsilon)' );
plt.title( 'd(sigma)/d(epsilon) vs sigma' );
##
###Step 1: plot x( true stress-yield stress) vs., y(d_sigma/d_epsilon), 
###Step 2: fit the linear portion of the curve (after the initial bend), 
###Step 3: get the intercept values on abscissa and ordinate axes.
##
smooth_width = 500
x1 = np.linspace(-6,6,smooth_width)
norm = np.sum(np.exp(-x1**2)) * (x1[1]-x1[0]) # ad hoc normalization
y1 = (4*x1**2 - 2) * np.exp(-x1**2) / smooth_width *8#norm*(x1[1]-x1[0])
y_conv_2 = np.convolve(KMY, y1, mode="same")
plt.plot(KMX,y_conv_2, label = "second deriv")

min_value = -2.5;
max_value = 5;
max_index = 0;
min_index = 0;
for i in range(len(KMX)):
  if(KMX[i]>235 and y_conv_2[i]<=max_value and max_index==0):
    max_index = i;
  if(KMX[i]<310 and y_conv_2[i]>=min_value):
    min_index = i;
print(max_index, min_index, KMX[max_index], KMX[min_index], y_conv_2[max_index], y_conv_2[min_index])

plt.plot(KMX,y_conv_2, label = "second deriv")
plt.xlim([KMX[max_index],KMX[min_index]])
plt.ylim([-10,10])

plt.plot(KMX, KMY)
plt.xlabel("KMX")
plt.ylabel("KMY")
plt.title("Linear portion of KMX and KMY")
plt.xlim([KMX[max_index],KMX[min_index]])

def objective_2(x, a, b):
 return a * x + b

popt, _ = curve_fit(objective_2, KMX[max_index:min_index],KMY[max_index:min_index])
a, b = popt
print('y = %.5f * x + %.5f' % (a, b))

print('x-intercept = %.5f, y-intercept = %.5f'%(-b/a, b)) 
